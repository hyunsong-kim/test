using System;
using System.Collections.Concurrent;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using Newtonsoft.Json;
using RabbitMQ.Client;

public sealed class RealtimePublisherWithDedupV7 : IDisposable
{
    private readonly IConnection _conn;
    private readonly ConcurrentBag<IChannel> _channelPool = new ConcurrentBag<IChannel>();
    private readonly ConcurrentDictionary<string,long> _seen = new(StringComparer.Ordinal);

    private readonly Timer _gcTimer;
    private readonly string _exchange, _routingKey;
    private readonly TimeSpan _dedupTtl;
    private readonly int _maxKeys;

    private volatile int _topologyReady = 0;

    public RealtimePublisherWithDedupV7(
        string host="localhost", string user="guest", string pass="guest",
        string exchange="bulk.ex", string routingKey="bulk",
        TimeSpan? dedupTtl=null, int maxKeys=1_000_000, int initialChannels=2)
    {
        _exchange = exchange; _routingKey = routingKey;
        _dedupTtl = dedupTtl ?? TimeSpan.FromMinutes(10);
        _maxKeys = Math.Max(10_000, maxKeys);

        var f = new ConnectionFactory {
            HostName = host, UserName = user, Password = pass,
            AutomaticRecoveryEnabled = true,
            NetworkRecoveryInterval = TimeSpan.FromSeconds(5)
        };
        _conn = f.CreateConnection(); // ✅ 한 번만 생성(재사용)

        for (int i = 0; i < initialChannels; i++)
            _channelPool.Add(CreateChannel());

        // 주기적 dedup 정리
        _gcTimer = new Timer(_ => Cleanup(), null, 60_000, 60_000);
    }

    private IChannel CreateChannel()
    {
        var ch = _conn.CreateChannel();               // ✅ IChannel (v7)
        // 퍼블리셔 컨펌 활성화(Async가 권장이지만, ConfirmSelect()도 제공됨)
        ch.ConfirmSelect();                            // 또는: await ch.ConfirmSelectAsync()
        return ch;
    }

    private IChannel Borrow() => _channelPool.TryTake(out var ch) ? ch : CreateChannel();
    private void Return(IChannel ch)
    {
        if (ch != null && ch.IsOpen) _channelPool.Add(ch);
        else ch?.Dispose();
    }

    private async Task EnsureTopologyAsync(IChannel ch)
    {
        if (Interlocked.CompareExchange(ref _topologyReady, 1, 0) == 0)
        {
            await ch.ExchangeDeclareAsync(_exchange, ExchangeType.Direct, durable: true);
            // 큐/바인딩을 여기서 같이 할 거면 아래처럼:
            // await ch.QueueDeclareAsync("bulk.q", durable:true, exclusive:false, autoDelete:false);
            // await ch.QueueBindAsync("bulk.q", _exchange, _routingKey);
        }
    }

    /// <summary>
    /// 단건 전송(Async). 중복키면 false, 신규면 true.
    /// </summary>
    public async Task<bool> TryPublishAsync(string table, string key, object payload, bool perMessageConfirm = true)
    {
        if (string.IsNullOrWhiteSpace(key)) throw new ArgumentException("key required");

        var nowTicks = DateTime.UtcNow.Ticks;
        if (!_seen.TryAdd(key, nowTicks)) return false;     // ✅ 프로세스 내 멱등

        // 메시지 직렬화
        var body = Encoding.UTF8.GetBytes(JsonConvert.SerializeObject(new {
            Table = table, Key = key, Payload = payload, Ts = DateTime.UtcNow
        }));

        // BasicProperties (v7: new 로 생성)
        var props = new BasicProperties
        {
            ContentType = "application/json",
            DeliveryMode = 2,     // 2 = persistent
            MessageId = key
        };

        var ch = Borrow();
        try
        {
            await EnsureTopologyAsync(ch);

            await ch.BasicPublishAsync(
                exchange: _exchange,
                routingKey: _routingKey,
                mandatory: true,
                basicProperties: props,
                body: body
            );

            if (perMessageConfirm)
                await ch.WaitForConfirmsAsync(TimeSpan.FromSeconds(5));
        }
        finally
        {
            Return(ch);
        }
        return true;
    }

    /// <summary>
    /// 배치 컨펌: perMessageConfirm=false 로 여러 번 보낸 뒤 한 번에 호출.
    /// </summary>
    public async Task FlushConfirmsAsync(TimeSpan? timeout = null)
    {
        var ch = Borrow();
        try
        {
            await ch.WaitForConfirmsAsync(timeout ?? TimeSpan.FromSeconds(5));
        }
        finally
        {
            Return(ch);
        }
    }

    private void Cleanup()
    {
        var expire = DateTime.UtcNow - _dedupTtl;

        if (_seen.Count > _maxKeys)
        {
            int target = _maxKeys / 2, removed = 0;
            foreach (var kv in _seen)
            {
                if (removed >= _seen.Count - target) break;
                _seen.TryRemove(kv.Key, out _); removed++;
            }
            return;
        }
        foreach (var kv in _seen)
        {
            if (new DateTime(kv.Value, DateTimeKind.Utc) < expire)
                _seen.TryRemove(kv.Key, out _);
        }
    }

    // ✅ IDisposable 내에서 v7 비동기 종료 API 정리
    public void Dispose()
    {
        _gcTimer?.Dispose();

        // 채널 먼저 종료
        while (_channelPool.TryTake(out var ch))
        {
            try { ch.CloseAsync().GetAwaiter().GetResult(); } catch { /* ignore */ }
            try
            {
                if (ch is IAsyncDisposable iad) iad.DisposeAsync().AsTask().Wait();
                else (ch as IDisposable)?.Dispose();
            } catch { /* ignore */ }
        }

        // 연결 종료
        if (_conn != null)
        {
            try { _conn.Close(); } catch { /* CloseAsync도 가능 */ }
            try { _conn.Dispose(); } catch { }
        }
    }
}
